<?php
/**
 * Created by PhpStorm.
 * User: Administrator
 * Date: 14-12-4
 * Time: 下午2:24
 * 认识正则表达式
 * 1.正则表达式就是一个匹配的“模式”
 * 2.正则表达式本身就是一个字符串（中有些语法规则，特殊字符）
 *  正则表达式这个字符串，一定要在对应的函数中使用。（分割的函数，替换的函数）
 *
 */
$text = <<<st
【韩国女子网上直播吃饭 月收入超5万人民币】最近，韩国http://www.gjla.net流行女生“吃饭直播”真人秀。
原为一家咨询公司白领的朴淑妍，辞职专心做起了“吃饭直播”。每天中午花三小时，对http://www.baidu.com
着镜头把整桌食物吃掉，观看直播的网友就会给她“送气球”， 每个气http://www.google.org球100韩元，她月
收入超过5万人民币。
st;
$str = "/http\:\/\/www(.*?)(org|com|net)/i";

/*
 *定界符：多种都可以，常用为//，{},##
 * 原子：最小的一个匹配单位（放在定界符中），在一个正则表达式中，至少要有一个原子
 * 元字符：不能单独使用的，修饰原子，是用来扩展原子功能的和限定功能（写在定界符号中）
 * 模式修正符号：修正、对模式（正则）修正，（写在定界符号外面，写在右边）
 */
$str1 = "aaaaaaaaa3aaaaaaaaaaa5aaaaaaaaaaaa777aaaaaaaaaa9aaaa0aaaaaaa<br>";
$reg = "/\d/";
echo $str1 . '<br>';
echo preg_replace($reg, "#", $str1) . '<br>';
//print_r(preg_split($reg,$str1));
function preg($reg, $str1)
{
    if (preg_match($reg, $str1, $arr)) {
        echo "正则表达式<b> {$reg} </b>和字符串<b>{$str1}</b>匹配成功！<br>";
        print_r($arr);
    } else {
        echo "匹配失败<br>";
    }
}

echo preg($reg, $str1) . '<br>';
/*
 * 原子：1、打印字符（a-z A-Z 0-9 !@#$%^&*()_+）和非打印字符
 *      \ -- 转义字符   可以将有意义的字符转成没有意义的原子字符(将有意义变成原子)；
 *              可以将没有意义的字符转成有意义的原子；
 *              a-z A-Z 0-9 _ 所有没有意义的字符，加上转义也没有意义的，\@都是可加可不加的
 *  2、所有的数字，所有的字，所有的空白，所有的字母，所有的特殊符号
 *  \d  代表所有十进制数字  = [0-9]
 *  \D  任意非十进制数字    = [^0-9]
 *  \s  任意空白字符
 *  \S  任意非空白字符
 *  \w  任意单词字符 a-z A-Z 0-9 _
 *  \W  任意非单词字符 除了 a-z A-Z 0-9 _ 之外的所有字符
 *
 *  3、自定义原子表
 *      [13579]   [^a-zA-Z]
 *  4、点（.）能代表所有的
 */
$s = "This is test<br>";
$reg1 = "/\w/";
echo preg($reg1, $s) . '<br>';

/*
 * 元字符：这个不能在正则表达式中单独使用，用来修饰原子的
 *      *：量词，0 次或多次匹配前面的原子  {0,}
 *      +：量词，1 次或多次匹配，至少要出现一次   {1,}
 *      ？：量词，表示 0 次或 1 次匹配。修饰其前面的原子可以出现0次或1次。{0,1}
 *      | :开始一个可选分支,或的关系，表示两边的原子只要有一个出现就可以，但是，|优先级是最低的
 *      {n}:表示其前面的原子恰好出现n次，多一次和少一次都不可以
 *      {n,}:表示其前面的原子出现至少n次
 *      {n,m}:表示其前面的原子至少出现n次，最多出现m次
 *      ^或\A:匹配输入字符串的开始位置（或在多行模式下行的开头，即紧随一个换行符之后）,必须写在正则的最前面
 *      $或\Z:匹配输入字符串的结束位置（或在多行模式下行的结尾，即紧随一个换行符之前）,必须写在正则的最后面
 *      \b:匹配单词的边界
 *      \B:匹配除单词边界之外的部分
 *      ():匹配其整体为一个原子，即模式单元，可以理解为由多个单个原子组成的大原子,反向引用
 */
$s1 = "This is google test<br>";
$reg2 = "/go?gle/";
$reg3 = "/\bgo\B/";
$reg4 = '/\d{4}(-|\/)\d{2}\1\d{2}/'; //反向引用
$reg4 = '/（？：\d{4}）(-|\/)\d{2}\1\d{2}/'; //?:使括号只有优先级的作用，没有反向引用作用
echo preg($reg3, $s1) . '<br>';